// TooltipManager.cs (Definitive Width Control for Nested Layouts)
using System.Collections;
using UnityEngine;
using UnityEngine.UI;

public class TooltipManager : MonoBehaviour
{
    public static TooltipManager Instance;

    [Header("Core Configuration")]
    public Tooltip tooltipPrefab;

    [Header("Animation Settings")]
    public float fadeDuration = 0.2f;

    [Header("Layout Settings")]
    [Tooltip("The maximum width the tooltip can have before text starts wrapping.")]
    public float maxTooltipWidth = 350f;

    [Header("Positioning")]
    public Vector2 positionOffset = new Vector2(0, -20);

    // --- Private State ---
    private Tooltip tooltipInstance;
    private RectTransform tooltipRectTransform;
    private CanvasGroup tooltipCanvasGroup;
    private Coroutine activeCoroutine;

    private void Awake()
    {
        if (Instance == null) { Instance = this; }
        else { Destroy(gameObject); }
    }

    private void Start()
    {
        Canvas rootCanvas = FindFirstObjectByType<Canvas>();
        if (rootCanvas == null)
        {
            Debug.LogError("Tooltip Manager Error: No Canvas found in the scene.");
            return;
        }

        GameObject tooltipObject = Instantiate(tooltipPrefab.gameObject, rootCanvas.transform, false);
        tooltipInstance = tooltipObject.GetComponent<Tooltip>();
        tooltipRectTransform = tooltipObject.GetComponent<RectTransform>();
        tooltipCanvasGroup = tooltipInstance.GetComponent<CanvasGroup>();

        tooltipInstance.gameObject.SetActive(false);
    }

    public void ShowTooltip(string content, string title, Sprite icon, float delay)
    {
        if (tooltipInstance == null) return;
        if (activeCoroutine != null) { StopCoroutine(activeCoroutine); }
        activeCoroutine = StartCoroutine(ShowRoutine(content, title, icon, delay));
    }

    public void HideTooltip()
    {
        if (tooltipInstance == null) return;
        if (activeCoroutine != null) { StopCoroutine(activeCoroutine); }
        if (tooltipInstance.gameObject.activeInHierarchy)
        {
            activeCoroutine = StartCoroutine(FadeOut());
        }
    }

    private IEnumerator ShowRoutine(string content, string title, Sprite icon, float delay)
    {
        yield return new WaitForSeconds(delay);
        yield return ResizeTooltipRoutine(content, title, icon);

        tooltipInstance.gameObject.SetActive(true);
        tooltipInstance.transform.SetAsLastSibling();
        PositionTooltip();

        activeCoroutine = StartCoroutine(FadeIn());
    }

    private IEnumerator ResizeTooltipRoutine(string content, string title, Sprite icon)
    {
        tooltipCanvasGroup.alpha = 0;
        tooltipInstance.gameObject.SetActive(false);

        // --- THE DEFINITIVE FIX FOR YOUR HIERARCHY ---
        // 1. Manually set the width of the child text objects' RectTransforms.
        // This provides the constraint that was missing.
        RectTransform titleRect = tooltipInstance.titleField.GetComponent<RectTransform>();
        RectTransform contentRect = tooltipInstance.contentField.GetComponent<RectTransform>();

        titleRect.sizeDelta = new Vector2(maxTooltipWidth, titleRect.sizeDelta.y);
        contentRect.sizeDelta = new Vector2(maxTooltipWidth, contentRect.sizeDelta.y);

        // 2. Set the text content AFTER constraining the width.
        // The text will now be forced to wrap within this boundary.
        tooltipInstance.SetText(content, title, icon);

        // 3. The "triple cycle" now forces the Vertical Fitters to calculate the correct height
        // based on the constrained width and wrapped text.
        for (int i = 0; i < 3; i++)
        {
            tooltipInstance.gameObject.SetActive(true);
            LayoutRebuilder.ForceRebuildLayoutImmediate(tooltipRectTransform);
            yield return new WaitForEndOfFrame();
            tooltipInstance.gameObject.SetActive(false);
        }
    }

    private IEnumerator FadeIn()
    {
        float startTime = Time.unscaledTime;
        while (Time.unscaledTime < startTime + fadeDuration)
        {
            tooltipCanvasGroup.alpha = Mathf.Lerp(0, 1, (Time.unscaledTime - startTime) / fadeDuration);
            yield return null;
        }
        tooltipCanvasGroup.alpha = 1;
    }

    private IEnumerator FadeOut()
    {
        float startTime = Time.unscaledTime;
        float startAlpha = tooltipCanvasGroup.alpha;
        while (Time.unscaledTime < startTime + fadeDuration)
        {
            tooltipCanvasGroup.alpha = Mathf.Lerp(startAlpha, 0, (Time.unscaledTime - startTime) / fadeDuration);
            yield return null;
        }
        tooltipCanvasGroup.alpha = 0;
        tooltipInstance.gameObject.SetActive(false);
    }

    private void PositionTooltip()
    {
        Vector3 mousePosition = Input.mousePosition;
        Vector3 tooltipPosition = mousePosition + (Vector3)positionOffset;

        float clampedX = Mathf.Clamp(tooltipPosition.x, 0, Screen.width - tooltipRectTransform.rect.width);
        float clampedY = Mathf.Clamp(tooltipPosition.y, tooltipRectTransform.rect.height, Screen.height);

        tooltipRectTransform.position = new Vector3(clampedX, clampedY, 0);
    }
}