// TooltipManager.cs (Definitive - Text Pre-processing)
using System.Collections;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class TooltipManager : MonoBehaviour
{
    public static TooltipManager Instance;

    [Header("Core Configuration")]
    public Tooltip tooltipPrefab;
    [Header("Layout Settings")]
    public float maxTooltipWidth = 350f;
    [Header("Animation Settings")]
    public float fadeDuration = 0.2f;
    [Header("Positioning")]
    public Vector2 positionOffset = new Vector2(0, -20);

    // Private State
    private Tooltip tooltipInstance;
    private RectTransform tooltipRectTransform;
    private CanvasGroup tooltipCanvasGroup;
    private Coroutine activeCoroutine;

    private void Awake()
    {
        if (Instance == null) { Instance = this; }
        else { Destroy(gameObject); }
    }

    private void Start()
    {
        Canvas rootCanvas = FindFirstObjectByType<Canvas>();
        if (rootCanvas == null)
        {
            Debug.LogError("Tooltip Manager Error: No Canvas found in the scene.");
            return;
        }

        GameObject tooltipObject = Instantiate(tooltipPrefab.gameObject, rootCanvas.transform, false);
        tooltipInstance = tooltipObject.GetComponent<Tooltip>();
        tooltipRectTransform = tooltipObject.GetComponent<RectTransform>();
        tooltipCanvasGroup = tooltipInstance.GetComponent<CanvasGroup>();

        tooltipInstance.gameObject.SetActive(false);
    }

    public void ShowTooltip(string content, string title, Sprite icon, Color titleColor, Color iconColor, float delay)
    {
        if (tooltipInstance == null) return;
        if (activeCoroutine != null) { StopCoroutine(activeCoroutine); }
        activeCoroutine = StartCoroutine(ShowRoutine(content, title, icon, titleColor, iconColor, delay));
    }

    public void HideTooltip()
    {
        if (tooltipInstance == null) return;
        if (activeCoroutine != null) { StopCoroutine(activeCoroutine); }
        if (tooltipInstance.gameObject.activeInHierarchy)
        {
            activeCoroutine = StartCoroutine(FadeOut());
        }
    }

    private IEnumerator ShowRoutine(string content, string title, Sprite icon, Color titleColor, Color iconColor, float delay)
    {
        yield return new WaitForSeconds(delay);
        yield return ResizeTooltipRoutine(content, title, icon, titleColor, iconColor);

        tooltipInstance.gameObject.SetActive(true);
        tooltipInstance.transform.SetAsLastSibling();
        PositionTooltip();

        activeCoroutine = StartCoroutine(FadeIn());
    }

    private IEnumerator ResizeTooltipRoutine(string content, string title, Sprite icon, Color titleColor, Color iconColor)
    {
        tooltipCanvasGroup.alpha = 0;
        tooltipInstance.gameObject.SetActive(false);

        // --- THE DEFINITIVE FIX: TEXT PRE-PROCESSING ---

        // 1. Manually wrap the text strings if they exceed the max width.
        string wrappedTitle = WrapText(title, tooltipInstance.titleField, maxTooltipWidth);
        string wrappedContent = WrapText(content, tooltipInstance.contentField, maxTooltipWidth);

        // 2. Set the tooltip with the new, pre-wrapped strings.
        tooltipInstance.SetText(wrappedContent, wrappedTitle, icon, titleColor, iconColor);

        // 3. The "triple cycle" now works perfectly because the layout system
        // is just calculating the size of text that already has line breaks in it.
        for (int i = 0; i < 3; i++)
        {
            tooltipInstance.gameObject.SetActive(true);
            LayoutRebuilder.ForceRebuildLayoutImmediate(tooltipRectTransform);
            yield return new WaitForEndOfFrame();
            tooltipInstance.gameObject.SetActive(false);
        }
    }

    // This is the new helper method that contains the core logic.
    private string WrapText(string originalText, TMP_Text textComponent, float maxWidth)
    {
        if (string.IsNullOrEmpty(originalText) || textComponent == null)
        {
            return originalText;
        }

        // If the text is already narrower than the max width, we don't need to do anything.
        float preferredWidth = textComponent.GetPreferredValues(originalText).x;
        if (preferredWidth <= maxWidth)
        {
            return originalText;
        }

        // The text is too wide, so we must manually insert line breaks.
        StringBuilder wrappedText = new StringBuilder();
        string[] words = originalText.Split(' ');
        string currentLine = "";

        for (int i = 0; i < words.Length; i++)
        {
            string testLine = string.IsNullOrEmpty(currentLine) ? words[i] : $"{currentLine} {words[i]}";
            float testLineWidth = textComponent.GetPreferredValues(testLine).x;

            if (testLineWidth > maxWidth)
            {
                // The new word makes the line too long, so append the previous line and start a new one.
                wrappedText.AppendLine(currentLine);
                currentLine = words[i];
            }
            else
            {
                // The word fits, so add it to the current line.
                currentLine = testLine;
            }
        }

        // Append the last remaining line.
        wrappedText.Append(currentLine);

        return wrappedText.ToString();
    }

    private IEnumerator FadeIn()
    { /* ... unchanged ... */
        float startTime = Time.unscaledTime;
        while (Time.unscaledTime < startTime + fadeDuration)
        {
            tooltipCanvasGroup.alpha = Mathf.Lerp(0, 1, (Time.unscaledTime - startTime) / fadeDuration);
            yield return null;
        }
        tooltipCanvasGroup.alpha = 1;
    }

    private IEnumerator FadeOut()
    { /* ... unchanged ... */
        float startTime = Time.unscaledTime;
        float startAlpha = tooltipCanvasGroup.alpha;
        while (Time.unscaledTime < startTime + fadeDuration)
        {
            tooltipCanvasGroup.alpha = Mathf.Lerp(startAlpha, 0, (Time.unscaledTime - startTime) / fadeDuration);
            yield return null;
        }
        tooltipCanvasGroup.alpha = 0;
        tooltipInstance.gameObject.SetActive(false);
    }

    private void PositionTooltip()
    { /* ... unchanged ... */
        Vector3 mousePosition = Input.mousePosition;
        Vector3 tooltipPosition = mousePosition + (Vector3)positionOffset;

        float clampedX = Mathf.Clamp(tooltipPosition.x, 0, Screen.width - tooltipRectTransform.rect.width);
        float clampedY = Mathf.Clamp(tooltipPosition.y, tooltipRectTransform.rect.height, Screen.height);

        tooltipRectTransform.position = new Vector3(clampedX, clampedY, 0);
    }
}